var betterAuctionSource = "pragma solidity ^0.4.8;contract BetterAuction { address public beneficiary; uint256 public auctionStart; uint256 public biddingPeriod; uint256 public recoveryAfterPeriod; uint256 public constant WITHDRAWAL_TRIGGER_AMOUNT = 100000000000000; address public highestBidder; uint256 public highestBid; mapping(address => uint256) pendingReturns; bool auctionClosed; modifier isBeneficiary { if (msg.sender != beneficiary) throw; _; } modifier isAuctionActive { if (now < auctionStart || now > (auctionStart + biddingPeriod)) throw; _; } modifier isAuctionEnded { if (now < (auctionStart + biddingPeriod)) throw; _; } modifier isRecoveryActive { if (now < (auctionStart + recoveryAfterPeriod)) throw; _; } event HighestBidIncreased(address bidder, uint256 amount); event AuctionClosed(address winner, uint256 amount); function BetterAuction( address _beneficiary, uint256 _biddingPeriod, uint256 _recoveryAfterPeriod ) { if (_beneficiary == 0) throw; beneficiary = _beneficiary; auctionStart = now; if (_biddingPeriod > _recoveryAfterPeriod) throw; biddingPeriod = _biddingPeriod; recoveryAfterPeriod = _recoveryAfterPeriod; } function auctionEndTime() constant returns (uint256) { return auctionStart + biddingPeriod; } function getBid(address _address) constant returns (uint256) { if (_address == highestBidder) { return highestBid; } else { return pendingReturns[_address]; } } function bidderUpdateBid() internal { if (msg.sender == highestBidder) { highestBid += msg.value; HighestBidIncreased(msg.sender, highestBid); } else if (pendingReturns[msg.sender] + msg.value > highestBid) { var amount = pendingReturns[msg.sender] + msg.value; pendingReturns[msg.sender] = 0; pendingReturns[highestBidder] = highestBid; highestBid = amount; highestBidder = msg.sender; HighestBidIncreased(msg.sender, amount); } else { throw; } } function bidderPlaceBid() isAuctionActive payable { if ((pendingReturns[msg.sender] > 0 || msg.sender == highestBidder) && msg.value > 0) { bidderUpdateBid(); } else { if (msg.value <= highestBid) throw; if (highestBidder != 0) { pendingReturns[highestBidder] = highestBid; } highestBidder = msg.sender; highestBid = msg.value; HighestBidIncreased(msg.sender, msg.value); } } function beneficiaryRecoverFunds() isBeneficiary isRecoveryActive { if (!beneficiary.send(this.balance)) throw; } function nonHighestBidderRefund() payable { var amount = pendingReturns[msg.sender]; if (amount > 0) { pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount + msg.value)) throw; } else { throw; } } function beneficiaryCloseAuction() isBeneficiary isAuctionEnded { if (auctionClosed) throw; auctionClosed = true; AuctionClosed(highestBidder, highestBid); if (!beneficiary.send(highestBid)) throw; } function () payable { if (msg.value == WITHDRAWAL_TRIGGER_AMOUNT) { nonHighestBidderRefund(); } else { bidderPlaceBid(); } }}"